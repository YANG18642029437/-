

[TOC]



# 1,对象导论

## 1.1 抽象的过程

### 1.1.1 什么为抽象

> 对复杂问题的一种抽取，将问题简单化

### 1.1.2 面向对象的 5 大特征

> 1，万物皆对象
>
> 2，程序是对象的集合，它们通过发送消息来告诉彼此所要做的
>
> 3，每个对象都有自己的由其他对象所构成的存储     大白话 可以通过包含现有对象的方式创建新类型的对象
>
> 4，每个对象都拥有器类型    每个对象都是某个类的实例
>
> 5，某一特定类型的所有对象都可以接收同样的消息    表示 只要能接收相同消息的对象就是同一类型，也就是所谓的多态

## 1.2 每个对象都有一个接口

> 所有对象都是唯一的，但同时也是具有相同的特性和行为的对象所归属的类的一部分

## 1.3 每个对象都提供服务

> 将对象看做 服务的提供者
>
> 每个对象只提供相对的服务，不进行过多的服务

## 1.4 被隐藏的具体实现

> 将一个服务的具体实现过程隐藏起来，不被外人发现

## 1.5 复用具体实现

> 这里具体所指的是聚合而不是继承
>
> 当一个对象包含另一个类的具体实现，就表示当前对象是一个聚合对象

## 1.6 继承

> 当想要对某一对象的功能进行增强的时候，就就可以使用继承，对基类进行增强从而产生导出类
>
> 当继承进行到多层的时候，类型层次结构同时体现了集合形状之间的相似性和差异性

### 1.6.2 判断是否是同一类型

> 由于通过发送给类的消息的类型可知类的类型，所以这也就意味着导出类与基类具有相同的类型
>
> 但是导出类具有基类所不具有的特性，所以导出类不能算作基类

### 1.6.3 使导出类和基类产生差异的两种方法

> 1，直接在导出类中添加新的方法，对导出类进行增强
>
> 2，使用覆盖（overriding）的形式修个基类中的方法

### 1.6.4 “是一个” 与 “像是一个” 关系

> 当继承关系中只使用覆盖的方法（不添加新的方法）的时候导出类和基类具有完全相同的接口，这可以被视为纯粹替代，通常称之为替代原则，我们通常将这种情况称为 is-a （是一个关系）
>
> 当继承关系中必须添加新的接口元素，这样也就扩展了接口，这种情况称为 is-like-a （像是一个） 关系
>
> 这两种关系都是有可取性的

## 1.7 伴随多态的可互换对象

> 把导出类当做基类来使用是一种普遍的现象，可以提高代码的复用性，降低代码的维护难度

### 1.7.1 伴随多态的函数调用问题

> 为什么java总是能执行正确的函数
>
> 传统的函数调用中，编译器将会产生对一个具体函数名字的调用，而运行时将这个调用解析到将要被执行的代码的绝对地址 这种绑定叫做前期绑定
>
> 而在 oop 的函数调用中，程序直到运行时才能确定代码的地址，所以当消息发送到一个泛化对象时，使用一种全新的机制  “后期绑定”  当面向对象发送消息时被调用的代码直到运行时才能确定 Java使用一小段特殊的代码来替代绝对地址调用，这段代码使用在对象中存储的信息类计算方法体的地址，编译器是用来保证方法的存在，并对调用参数和返回值执行类型检查（无法提供此类保证的语言被称为弱类型语言），但是并不知道将被执行的确切代码

## 1.8 单根继承结构

> 所有的类最终都继承 Object 这一单一类
>
> 单根继承结构中的所有对象都具有一个公共用接口，所以它们归根到底都是相同的基本类型
>
> 单根继承的好处
>
> ​	单根继承保证所有的对象都具备某些功能，所有对象都可以很容易的在堆上创建，参数的传递也得到了极大的简化，并且使垃圾回收器的实现变得容易得多

## 1.9 容器

> 相对面向过程的语言中的集合使用的不方便，面向对象中一般都会包含一组好用的容器。
>
> java中就包含一组好用的容器 List Map Set 以及包含 诸如队列，树，堆栈等更多的构件
>
> 不同的类型在不同的环境下有不同的效率

### 1.9.1 参数化类型

> 也就是泛型，在javaSE5之前 容器存储都只能存储 Object 类型但是在 javaSE5 的更新中添加了一种全新的机制 就是泛型 可以再 容器定义的时候规定容器的存储类型

## 1.10 对象的创建和生命期

> 每个对象为了生存都需要资源，尤其是内存。当我们不在需要一个对象时，它必须被清理掉，其占有的资源可以被释放和重用

> java 中采用垃圾回收机制来处理内存释放的问题。垃圾回收器 “知道” 对象何时不再被使用，并自动释放对象占用的内存。这一点同所有对象都继承自单根基类的Object以及只能以一种方式创建对象（在堆栈上创建） 这两个特性结合起来，使得用java编程要较之C++编程要简单的多

## 1.11 异常处理： 处理错误

> 处理错误的难处在于，普通的编程语言会将错误的处理依赖于程序员自身的警惕，这种警惕性来源于来源于一种共同的约定，而不是编程语言所强制的。如果程序员不够警惕，这些机制很容易就会被忽视

### 1.11.1 java 的异常处理机制

> 将异常看做为一种对象，它从出错点被 “ 抛出 ” 并被专门设计用来处理特定类型错误的相应的异常处理器 “ 捕获 ” 异常处理就像是与程序正常执行路径并行的，在错误发生时执行的另一条路径
>
> java 的异常处理在众多编程语言中格外引人注目，因为Java一开始就内置了异常处理，而且强制你必须使用它

## 1.12 并发编程

> 当我们需要程序停下当前正在做的工作，转而处理某个其他问题，然后再返回主进程
>
> 对于大量的其他问题，我们想要将问题拆分为多个可独立运行的部分，从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为 “ 并发 ”
>
> 但是并发编程有一个隐患，就是共享资源，如果有多个并行任务，都要访问同一资源，就要设定资源锁，只有当前线程完成资源访问的时候，才会释放资源锁

## 1.13 Java与Internet

## 1.14 总结

> 等我更加深入的理解 Java



# 2，一切都是对象

[^如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界]: - Luduing Wittgerstein

## 2.1 用引用操作对象

> 一切都被视为对象，因此可以采用单一固定的语法。尽管一切都看做对象，但操作的标识符实际上是对象的一个 " 引用 " （reference）
>
> 当您拥有一个引用的时候，不一定需要有一个对象与它关联 
>
> String str;
>
> 但是当你使用这样的一个对象的时候就会报空指针异常

## 2.2 必须由你创建所有对象

> 所有的对象都是通过 new 的方式创建的，一旦创建了一个引用，就希望它能与一个新的对象相关联

### 2.2.1 存储到什么地方

> 1，寄存器
>
> ​	这里是最快的存储区，寄存器的存储数量有限，但是在Java中你并不能直接对寄存器进行操作
>
> 2，堆栈
>
> ​	位于通用RAM中，但是通过