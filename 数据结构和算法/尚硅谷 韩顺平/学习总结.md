# 数据结构

## 线性结构和非线性结构

### 线性结构

+ 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
+ 线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。
+ 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及响铃元素的地址信息
+ 线性结构常见的有：数组，队列，链表和栈

### 非线性结构

+ 非线性结构包括： 二维数组，多维数组，广义表，树结构，图结构

## 稀疏数组和队列

<img src="D:\成长笔记\数据结构和算法\尚硅谷 韩顺平\image\image-20200327115131101.png" alt="image-20200327115131101" style="zoom:80%;" />

> 将一个 二维数组转换 为记录值的 三维数组

```java
		public static void main(String[] args) throws IOException, ClassNotFoundException {
        int[][] arr = new int[11][11];
        arr[1][2] = 1;
        arr[2][3] = 2;
        int num = 0;
        for (int[] ints : arr) {
            for (int anInt : ints) {
                if (anInt != 0){
                    num ++;
                }
            }
            System.out.println();
        }
        int[][] result = new int[num+1][3];
        result[0][0] = 11;
        result[0][1] = 11;
        result[0][2] = num;
        int index = 0;
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                if (arr[i][j] != 0){
                    index++;
                    result[index][0] = i;
                    result[index][1] = j;
                    result[index][2] = arr[i][j];
                }
            }
        }

        for (int[] ints : result) {
            System.out.println(Arrays.toString(ints));
        }

        ObjectOutputStream obj = new ObjectOutputStream(new FileOutputStream("1.data"));

        obj.writeObject(result);


        ObjectInputStream stream = new ObjectInputStream(new FileInputStream("1.data"));
        Object read = stream.readObject();
        result = (int[][])read;

        int[][] arr2 = new int[result[0][0]][result[0][1]];
        for (int i = 1; i < result.length; i++) {
            arr2[result[i][0]][result[i][1]] = result[i][2];
        }

        for (int i = 0; i < arr2.length; i++) {
            for (int j = 0; j < arr2[i].length; j++) {z
                System.out.print(arr2[i][j]+"\t");
            }
            System.out.println();
        }


    }
```

## 队列

### 介绍

+ 队列是一个有序列表，可以用数组或是链表来实现
+ 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出

数组模拟一个队列

```java
class QueueDemo {
    private Integer maxSize;
    private Integer front;
    private Integer rear;
    private int[] arr;

    public QueueDemo(Integer maxSize) {
        this.maxSize = maxSize;
        this.arr = new int[maxSize];
        this.front = -1;
        this.rear = -1;
    }

    public boolean isFull() {
        return rear == maxSize - 1;
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public void addQueue(int n) {
        if (isFull()) {
            System.out.println("超过最大容器");
            return;
        }
        arr[++rear] = n;
    }


    public int getQueue() {
        if (isEmpty()) {
            System.out.println("内容为空");
            throw new RuntimeException("内容为空");
        }
        return arr[++front];
    }
}
```

### 数组模拟一个环形队列

```java
class QueueDemo {
    private Integer maxSize;
    private Integer front;
    private Integer rear;
    private int[] arr;

    public QueueDemo(Integer maxSize) {
        this.maxSize = maxSize;
        this.arr = new int[maxSize];
        this.front = 0;
        this.rear = 0;
    }

    public boolean isFull() {
        return (rear+1) % maxSize == front;
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public void addQueue(int n) {
        if (isFull()) {
            System.out.println("超过最大容器");
            return;
        }
        arr[rear] = n;
        rear = (rear + 1) % maxSize;
    }


    public int getQueue() {
        if (isEmpty()) {
            System.out.println("内容为空");
            throw new RuntimeException("内容为空");
        }
        int res = arr[front];
        front = (front + 1) % maxSize;
        return res;
    }
}
```

## 链表

### 简介

+ 链表是以节点的方式来存储，是链式存储
+ 每个节点包含 data 域， next 域 ： 指向下一个节点
+ 链表中的各个节点的存储空间不一定是连续的
+ 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

### 单链表

+ 实例 实现单链表的曾删改查

```java
package com.yyx.数据结构;

public class 单链表实现 {
    public static void main(String[] args) {
        SingleLinkedList list = new SingleLinkedList();
        list.add2(new HeroNode(3,"杨家祥","是傻蛋"));
        list.add2(new HeroNode(3,"杨家祥1","是傻蛋1"));
        list.add2(new HeroNode(1,"杨家祥2","是傻蛋2"));
        list.add2(new HeroNode(2,"杨家祥3","是傻蛋3"));
        list.update(new HeroNode(2,"杨家祥二货","是傻蛋3"));
        list.delete(new HeroNode(2,"杨家祥二货","是傻蛋3"));
        list.list();
    }
}


class SingleLinkedList {
    private HeroNode head = new HeroNode(0,null,null);
    private HeroNode temp;

    public void delete(HeroNode node){
        if (head.next == null){
            System.out.println("链表为空");
        }
        HeroNode temp = head;
        while (temp.next != null){
            if (temp.next.no == node.no){
                temp.next = temp.next.next;
                return;
            }
            temp = temp.next;
        }
        System.out.printf("未找到和 $d 相同的节点",node.no);

    }


    public void update(HeroNode node) {
        if (head.next == null){
            System.out.println("链表为空");
        }
        HeroNode temp = head;
        while (temp.next != null){
            if (temp.next.no == node.no){
                node.next = temp.next.next;
                temp.next = node;
                return;
            }
            temp = temp.next;
        }
        System.out.println("未修改成功，不包此次元素");
    }

    /**
     * 添加一个节点到链表中
     * @param node
     */
    public void  add(HeroNode node){
        HeroNode temp = head;
        while (temp.next != null){
            temp = temp.next;
        }
        temp.next = node;
    }

    /**
     * 添加一个节点到链表中
     * @param node
     */
    public void  add2(HeroNode node){
        HeroNode temp = head;
        while (temp.next != null){
            HeroNode t1 = temp;
            temp = temp.next;
            if (temp.no == node.no){
                System.out.println("已有排位");
                return;
            }else if (temp.no > node.no){
                node.next = temp;
                t1.next = node;
                return;
            }
        }
        temp.next = node;
    }


    public void  list (){
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        HeroNode node = head;
        while (node.next != null){
            node = node.next;
            System.out.println(node);
        }
    }
}




class HeroNode{
    public int no;
    private String name;
    private String nickname;
    HeroNode next;


    public HeroNode(int no, String name, String nickname) {
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickname='" + nickname + '\''+
                '}';
    }
}
```

